{"version":3,"sources":["components/PageTemplate/PageTemplate.tsx","components/TodoInput/TodoInput.tsx","components/TodoItem/TodoItem.tsx","components/TodoList/TodoList.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["cx","classNames","bind","require","PageTemplate","_ref","children","react_default","a","createElement","className","TodoInput","value","onChange","onInsert","type","onKeyPress","e","key","onClick","TodoItem","nextProps","nextState","this","props","done","_this$props","onToggle","onRemove","checked","readOnly","stopPropagation","Component","TodoList","todos","todoList","map","todo","components_TodoItem_TodoItem","id","_onRemove","apply","arguments","toString","_onToggle","text","App","state","input","getId","_this","handleChange","currentTarget","setState","handleInsert","_this$state","newTodo","concat","Object","toConsumableArray","handleToggle","index","findIndex","toggled","objectSpread","slice","length","handleRemove","_this$state2","components_PageTemplate_PageTemplate","components_TodoInput_TodoInput","components_TodoList_TodoList","Boolean","window","location","hostname","match","ReactDOM","render","App_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.abfd314d.chunk.js","sourcesContent":["import React from \"react\";\nimport classNames from \"classnames/bind\";\n\nconst cx = classNames.bind(require(\"./PageTemplate.sass\"));\n\ninterface Props {}\nconst PageTemplate: React.SFC<Props> = ({ children }) => {\n  return (\n    <div className={cx(\"page-template\")}>\n      <h1>Todo List</h1>\n      <div className={cx(\"content\")}>{children}</div>\n    </div>\n  );\n};\n\nexport default PageTemplate;\n","import React from \"react\";\nimport classNames from \"classnames/bind\";\nconst cx = classNames.bind(require(\"./TodoInput.sass\"));\ninterface Props {\n  value: string;\n  onChange(e: React.FormEvent<HTMLInputElement>): void;\n  onInsert(): void;\n}\n\nconst TodoInput: React.SFC<Props> = ({ value, onChange, onInsert }) => {\n  const handleKeyPress = (e: React.KeyboardEvent<HTMLInputElement>): void => {\n    if (e.key === \"Enter\") {\n      onInsert();\n    }\n  };\n  return (\n    <div className={cx(\"todo-input\")}>\n      <input\n        type=\"text\"\n        onChange={onChange}\n        onKeyPress={handleKeyPress}\n        value={value}\n      />\n      <div className={cx(\"add-button\")} onClick={onInsert}>\n        ADD\n      </div>\n    </div>\n  );\n};\n\nexport default TodoInput;\n","import React, { Component } from \"react\";\nimport classNames from \"classnames/bind\";\nconst cx = classNames.bind(require(\"./TodoItem.sass\"));\ninterface Props {\n  done: boolean;\n  onToggle(): void;\n  onRemove(): void;\n}\ninterface State {}\nclass TodoItem extends Component<Props, State> {\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\n    return this.props.done !== nextProps.done;\n  }\n  render() {\n    const { done, children, onToggle, onRemove } = this.props;\n    return (\n      <div className={cx(\"todo-item\")} onClick={onToggle}>\n        <input className={cx(\"tick\")} type=\"checkbox\" checked={done} readOnly />\n        <div className={cx(\"text\", { done })}>{children}</div>\n        <div\n          className={cx(\"delete\")}\n          onClick={(e: React.MouseEvent<HTMLDivElement>): void => {\n            onRemove();\n            e.stopPropagation();\n          }}\n        >\n          [REMOVE]\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default TodoItem;\n","import React, { Component } from \"react\";\nimport TodoItem from \"../TodoItem/TodoItem\";\n\nexport interface Todo {\n  id: number;\n  text: string;\n  done: boolean;\n}\ninterface Props {\n  todos: Todo[];\n  onToggle(id: number): void;\n  onRemove(id: number): void;\n}\ninterface State {}\nclass TodoList extends Component<Props> {\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\n    return this.props.todos !== nextProps.todos;\n  }\n\n  render() {\n    const { todos, onToggle, onRemove } = this.props;\n    const todoList = todos.map(todo => (\n      <TodoItem\n        key={todo.id}\n        done={todo.done}\n        onRemove={() => onRemove(todo.id)}\n        onToggle={() => onToggle(todo.id)}\n      >\n        {todo.text}\n      </TodoItem>\n    ));\n    return <div>{todoList}</div>;\n  }\n}\n\nexport default TodoList;\n","import React, { Component } from \"react\";\nimport PageTemplate from \"./PageTemplate/PageTemplate\";\nimport TodoInput from \"./TodoInput/TodoInput\";\nimport TodoList, { Todo } from \"./TodoList/TodoList\";\ninterface Props {}\n\ninterface State {\n  input: string;\n  todos: Todo[] | undefined;\n}\nexport default class App extends Component<Props, State> {\n  state = {\n    input: \"\",\n    todos: [{ id: 0, text: \"Study React\", done: false }]\n  };\n  id = 1;\n  getId = (): number => {\n    return ++this.id;\n  };\n  handleChange = (e: React.FormEvent<HTMLInputElement>): void => {\n    const { value } = e.currentTarget;\n    this.setState({\n      input: value\n    });\n  };\n  handleInsert = (): void => {\n    const { todos, input } = this.state;\n\n    const newTodo: Todo = {\n      text: input,\n      done: false,\n      id: this.getId()\n    };\n    this.setState({\n      todos: [...todos, newTodo],\n      input: \"\"\n    });\n  };\n  handleToggle = (id: number): void => {\n    const { todos } = this.state;\n    const index = todos.findIndex(todo => todo.id === id);\n\n    const toggled = {\n      ...todos[index],\n      done: !todos[index].done\n    };\n    this.setState({\n      todos: [\n        ...todos.slice(0, index),\n        toggled,\n        ...todos.slice(index + 1, todos.length)\n      ]\n    });\n  };\n  handleRemove = (id: number): void => {\n    const { todos } = this.state;\n    const index = todos.findIndex(todo => todo.id === id);\n\n    this.setState({\n      todos: [...todos.slice(0, index), ...todos.slice(index + 1, todos.length)]\n    });\n  };\n  render() {\n    const { input, todos } = this.state;\n    const { handleChange, handleInsert, handleToggle, handleRemove } = this;\n    return (\n      <div>\n        <PageTemplate>\n          <TodoInput\n            value={input}\n            onChange={handleChange}\n            onInsert={handleInsert}\n          />\n          <TodoList\n            todos={todos}\n            onToggle={handleToggle}\n            onRemove={handleRemove}\n          />\n        </PageTemplate>\n      </div>\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./styles/main.sass\";\nimport App from \"./components/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}